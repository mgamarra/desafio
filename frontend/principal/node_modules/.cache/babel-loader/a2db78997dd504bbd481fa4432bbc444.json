{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar R = require('ramda');\n\nvar R__default = _interopDefault(R);\n\nvar redux = require('redux');\n\nvar RS = _interopDefault(require('ramdasauce')); // Creates a replacement reducer so we can listen for Reactotron messages\n// to clobber the state from the outside.\n\n\nvar DEFAULT_REPLACER_TYPE = 'REACTOTRON_RESTORE_STATE'; // creates a reducer which wraps the passed rootReducer\n\nvar createReplacementReducer = function createReplacementReducer(rootReducer) {\n  var actionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_REPLACER_TYPE; // return this reducer\n\n  return function (state, action) {\n    // is this action the one we're waiting for?  if so, use the state it passed\n    var whichState = action.type === actionName ? action.state : state;\n    return rootReducer(whichState, action);\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar DEFAULTS = {};\n\nvar createActionTracker = function createActionTracker(reactotron) {\n  var trackerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // verify reactotron is sane\n\n  if (!(R.is(Object, reactotron) && typeof reactotron.use === 'function')) {\n    throw new Error('invalid reactotron passed');\n  } // assemble a crack team of options to use\n\n\n  var options = R.merge(DEFAULTS, trackerOptions);\n  var exceptions = R.concat([DEFAULT_REPLACER_TYPE], options.except || []); // the store enhancer\n\n  return function (next) {\n    return function (reducer, initialState, enhancer) {\n      // create the original store\n      var store = next(reducer, initialState, enhancer); // return a new store\n\n      return _extends({}, store, {\n        // and a brand new dispatch function that wraps the old dispatch\n        dispatch: function dispatch(action) {\n          // start a timer\n          var elapsed = reactotron.startTimer(); // call the original dispatch that actually does the real work\n\n          var result = store.dispatch(action); // stop the timer\n\n          var ms = elapsed();\n          var unwrappedAction = action.type === 'PERFORM_ACTION' && action.action ? action.action : action; // if matchException is true, actionType is matched with exception\n\n          var matchException = function matchException(exception, actionType) {\n            if (typeof exception === 'string') {\n              return actionType === exception;\n            } else if (typeof exception === 'function') {\n              return exception(actionType);\n            } else if (exception instanceof RegExp) {\n              return exception.test(actionType);\n            } else {\n              return false;\n            }\n          };\n\n          var matchExceptions = R.any(function (exception) {\n            return matchException(exception, unwrappedAction.type);\n          }, exceptions); // action not blacklisted?\n          // if matchException is true, action.type is matched with exception\n\n          if (!matchExceptions) {\n            // check if the app considers this important\n            var important = false;\n\n            if (trackerOptions && typeof trackerOptions.isActionImportant === 'function') {\n              important = !!trackerOptions.isActionImportant(unwrappedAction);\n            }\n\n            reactotron.reportReduxAction(unwrappedAction, ms, important);\n          }\n\n          return result;\n        }\n      });\n    };\n  };\n};\n\nvar reportAction = function reportAction(reactotron, action, ms) {\n  var important = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // let's call the type, name because that's \"generic\" name in Reactotron\n\n  var name = action.type; // convert from symbol to type if necessary\n\n  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') {\n    name = name.toString().replace(/^Symbol\\(/, '').replace(/\\)$/, '');\n  } // off ya go!\n\n\n  reactotron.send('state.action.complete', {\n    name: name,\n    action: action,\n    ms: ms\n  }, important);\n};\n\nvar createStore$1 = function createStore$1(reactotron, rootReducer, preloadedState, enhancer) {\n  // shuffle around params if preloadedState is null\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  } // wrap the reducer with one which we can replace\n\n\n  var reducer = reactotron.createReplacementReducer(rootReducer); // wrap the enhancer with our beginning and ending one\n\n  var wrappedEnhancer = enhancer ? redux.compose(enhancer, reactotron.createActionTracker()) : reactotron.createActionTracker(); // call the redux create store\n\n  var store = redux.createStore(reducer, preloadedState, wrappedEnhancer); // remember this store\n\n  reactotron.setReduxStore(store);\n  return store;\n};\n\nvar getCleanedState = function getCleanedState(state) {\n  // If we have a toJS, lets assume we need to call it to get a plan 'ol JS object\n  // NOTE: This handles ImmutableJS\n  if (state.toJS) {\n    return state.toJS();\n  }\n\n  return state;\n}; // sends the key names at the given location\n\n\nvar requestKeys = function requestKeys(state, reactotron, path) {\n  var cleanedState = getCleanedState(state);\n\n  if (RS.isNilOrEmpty(path)) {\n    reactotron.stateKeysResponse(null, R__default.keys(cleanedState));\n  } else {\n    var keys = R__default.keys(RS.dotPath(path, cleanedState));\n    reactotron.stateKeysResponse(path, keys);\n  }\n}; // sends the values at the given location\n\n\nvar requestValues = function requestValues(state, reactotron, path) {\n  var cleanedState = getCleanedState(state);\n\n  if (RS.isNilOrEmpty(path)) {\n    // send the whole damn tree\n    reactotron.stateValuesResponse(null, cleanedState);\n  } else {\n    // send a leaf of the tree\n    reactotron.stateValuesResponse(path, RS.dotPath(path, cleanedState));\n  }\n}; // fishes out the values for the subscriptions in state and returns them\n\n\nvar getSubscriptionValues = function getSubscriptionValues(subscriptions, state) {\n  var cleanedState = getCleanedState(state);\n  return R__default.pipe(R__default.map(R__default.when(R__default.isNil, R__default.always(''))), R__default.filter(RS.endsWith('.*')), R__default.map(function (key) {\n    var keyMinusWildcard = R__default.slice(0, -2, key);\n    var value = RS.dotPath(keyMinusWildcard, cleanedState);\n\n    if (R__default.is(Object, value) && !RS.isNilOrEmpty(value)) {\n      return R__default.pipe(R__default.keys, R__default.map(function (key) {\n        return keyMinusWildcard + '.' + key;\n      }))(value);\n    }\n\n    return [];\n  }), R__default.concat(R__default.map(R__default.when(R__default.isNil, R__default.always('')), subscriptions)), R__default.flatten, R__default.reject(RS.endsWith('.*')), R__default.uniq, R__default.sortBy(R__default.identity), R__default.map(function (key) {\n    return {\n      path: key,\n      value: RS.isNilOrEmpty(key) ? cleanedState : RS.dotPath(key, cleanedState)\n    };\n  }))(subscriptions);\n};\n\nvar _this = undefined; // This is the new plugin I'll be promoting to the default export when we hit 2.x\n\nvar reactotronRedux = function reactotronRedux() {\n  var pluginConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (reactotron) {\n    // the one & only redux store --- TODO: find a better way to do this\n    var reduxStore = null; // which subscribed paths we're current listening to\n\n    var subscriptions = [];\n\n    var sendSubscriptions = function sendSubscriptions() {\n      var changes = getSubscriptionValues(subscriptions, reduxStore.getState());\n      reactotron.stateValuesChange(changes);\n    };\n\n    var sendSubscriptionsIfNeeded = function sendSubscriptionsIfNeeded() {\n      var changes = getSubscriptionValues(subscriptions, reduxStore.getState());\n\n      if (!R.isEmpty(changes)) {\n        sendSubscriptions();\n      }\n    }; // a chance to change the state before backup\n\n\n    var restoreActionType = pluginConfig.restoreActionType || DEFAULT_REPLACER_TYPE;\n    var onBackup = pluginConfig.onBackup || R.identity;\n    var onRestore = pluginConfig.onRestore || R.identity;\n    return {\n      // fires when we receive a command from Reactotron\n      onCommand: function onCommand(_ref) {\n        var type = _ref.type,\n            payload = _ref.payload;\n\n        switch (type) {\n          // client is asking for keys\n          case 'state.keys.request':\n            return requestKeys(reduxStore.getState(), reactotron, payload.path);\n          // client is asking for values\n\n          case 'state.values.request':\n            return requestValues(reduxStore.getState(), reactotron, payload.path);\n          // client is asking to subscribe to some paths\n\n          case 'state.values.subscribe':\n            subscriptions = R.pipe(R.flatten, R.uniq)(payload.paths);\n            sendSubscriptions();\n            return;\n          // server is asking to dispatch this action\n\n          case 'state.action.dispatch':\n            reduxStore.dispatch(payload.action);\n            return;\n          // server is asking to backup state\n\n          case 'state.backup.request':\n            {\n              // run our state through our onBackup\n              var state = onBackup(reduxStore.getState());\n              reactotron.send('state.backup.response', {\n                state: state\n              });\n              return;\n            }\n          // server is asking to clobber state with this\n\n          case 'state.restore.request':\n            {\n              // run our state through our onRestore\n              var _state = onRestore(payload.state, reduxStore.getState());\n\n              reduxStore.dispatch({\n                type: restoreActionType,\n                state: _state\n              });\n            }\n        }\n      },\n      // bestow these features on the Reactotron namespace\n      features: {\n        // a store enhancer which tracks actions for reporting\n        createActionTracker: createActionTracker.bind(_this, reactotron, pluginConfig),\n        // sends messages thru reactotron about the action\n        reportReduxAction: reportAction.bind(_this, reactotron),\n        // creates a replacement reducer for uploading new state\n        createReplacementReducer: createReplacementReducer,\n        // wraps redux's createStore for sane configuration\n        createStore: createStore$1.bind(_this, reactotron),\n        // sets the current redux store\n        setReduxStore: function setReduxStore(store) {\n          // remember\n          reduxStore = store; // subscribe\n\n          store.subscribe(sendSubscriptionsIfNeeded);\n        }\n      }\n    };\n  };\n};\n\nvar RESTORE_ACTION_TYPE = 'REACTOTRON_RESTORE_STATE';\n\nvar DEFAULT_ON_BACKUP = function DEFAULT_ON_BACKUP(state) {\n  return state;\n};\n\nvar DEFAULT_ON_RESTORE = function DEFAULT_ON_RESTORE(state) {\n  return state;\n};\n\nvar createPlugin = function createPlugin(store) {\n  var pluginConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // the action type we'll trigger restores on\n\n  var restoreActionType = pluginConfig.restoreActionType || RESTORE_ACTION_TYPE; // a chance to change the state before backup\n\n  var onBackup = pluginConfig.onBackup || DEFAULT_ON_BACKUP;\n  var onRestore = pluginConfig.onRestore || DEFAULT_ON_RESTORE; // hold onto the send\n\n  var capturedSend = void 0; // which subscribed paths we're current listening to\n\n  var subscriptions = []; // here's the plugin\n\n  var plugin = function plugin(reactotron) {\n    // remember the plugin's send function for use in the report() below.  :(\n    capturedSend = reactotron.send;\n\n    var sendSubscriptions = function sendSubscriptions() {\n      var changes = getSubscriptionValues(subscriptions, store.getState());\n      reactotron.stateValuesChange(changes);\n    };\n\n    var sendSubscriptionsIfNeeded = function sendSubscriptionsIfNeeded() {\n      var changes = getSubscriptionValues(subscriptions, store.getState());\n\n      if (!R.isEmpty(changes)) {\n        sendSubscriptions();\n      }\n    };\n\n    store.subscribe(sendSubscriptionsIfNeeded);\n    return {\n      // fires\n      onCommand: function onCommand(_ref) {\n        var type = _ref.type,\n            payload = _ref.payload;\n\n        switch (type) {\n          // client is asking for keys\n          case 'state.keys.request':\n            return requestKeys(store.getState(), reactotron, payload.path);\n          // client is asking for values\n\n          case 'state.values.request':\n            return requestValues(store.getState(), reactotron, payload.path);\n          // client is asking to subscribe to some paths\n\n          case 'state.values.subscribe':\n            subscriptions = R.pipe(R.flatten, R.uniq)(payload.paths);\n            sendSubscriptions();\n            return;\n          // server is asking to dispatch this action\n\n          case 'state.action.dispatch':\n            store.dispatch(payload.action);\n            return;\n          // server is asking to backup state\n\n          case 'state.backup.request':\n            {\n              // run our state through our onBackup\n              var state = onBackup(store.getState());\n              reactotron.send('state.backup.response', {\n                state: state\n              });\n              return;\n            }\n          // server is asking to clobber state with this\n\n          case 'state.restore.request':\n            {\n              // run our state through our onRestore\n              var _state = onRestore(payload.state);\n\n              store.dispatch({\n                type: restoreActionType,\n                state: _state\n              });\n            }\n        }\n      }\n    };\n  }; // attach a function that we can call from the enhancer\n\n\n  plugin.report = function (action, ms) {\n    var important = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!capturedSend) return; // let's call the type, name because that's \"generic\" name in Reactotron\n\n    var name = action.type; // convert from symbol to type if necessary\n\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') {\n      name = name.toString().replace(/^Symbol\\(/, '').replace(/\\)$/, '');\n    } // off ya go!\n\n\n    capturedSend('state.action.complete', {\n      name: name,\n      action: action,\n      ms: ms\n    }, important);\n  };\n\n  return plugin;\n};\n\nvar DEFAULTS$1 = {};\n\nvar createReactotronStoreEnhancer = function createReactotronStoreEnhancer(reactotron) {\n  var enhancerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // verify reactotron\n\n  if (!(R.is(Object, reactotron) && typeof reactotron.use === 'function')) {\n    throw new Error('invalid reactotron passed');\n  } // assemble a crack team of options to use\n\n\n  var options = R.merge(DEFAULTS$1, enhancerOptions);\n  var exceptions = R.concat(['REACTOTRON_RESTORE_STATE'], options.except || []); // an enhancer is a function that returns a store\n\n  var reactotronEnhancer = function reactotronEnhancer(createStore$$1) {\n    return function (reducer, initialState, enhancer) {\n      // the store to create\n      var store = createStore$$1(reducer, initialState, enhancer); // swizzle the current dispatch\n\n      var originalDispatch = store.dispatch; // create our dispatch\n\n      var dispatch = function dispatch(action) {\n        // start a timer\n        var elapsed = reactotron.startTimer(); // call the original dispatch that actually does the real work\n\n        var result = originalDispatch(action); // stop the timer\n\n        var ms = elapsed(); // action not blacklisted?\n\n        if (!R.contains(action.type, exceptions)) {\n          // check if the app considers this important\n          var important = false;\n\n          if (enhancerOptions && typeof enhancerOptions.isActionImportant === 'function') {\n            important = !!enhancerOptions.isActionImportant(action);\n          }\n\n          plugin.report(action, ms, important);\n        } // return the real work's result\n\n\n        return result;\n      };\n\n      var newStore = R.merge(store, {\n        dispatch: dispatch.bind(store)\n      }); // create the plugin with the store & a few passthru options\n\n      var plugin = createPlugin(newStore, {\n        onRestore: options.onRestore,\n        onBackup: options.onBackup\n      });\n      reactotron.use(plugin); // send the store back, but with our our dispatch\n\n      return newStore;\n    };\n  };\n\n  return reactotronEnhancer;\n};\n/* ----------------------------------\n   Begin backwards compatibility zone\n   ----------------------------------\n */\n// This is some goofy stuff to accomodate backwards compat.\n// a named version of the store enhancer (for backwards compat)\n\n\ncreateReactotronStoreEnhancer.createReactotronStoreEnhancer = createReactotronStoreEnhancer; // Creates a replacement reducer so we can listen for Reactotron messages\n// to clobber the state from the outside.\n\ncreateReactotronStoreEnhancer.createReplacementReducer = createReplacementReducer;\n/* --------------------------------\n   End backwards compatibility zone\n   --------------------------------\n */\n// This is the new plugin support.  Once we get out of the 1.x codebase range,\n// we'll upgrade this guy as the default.\n\ncreateReactotronStoreEnhancer.reactotronRedux = reactotronRedux;\nmodule.exports = createReactotronStoreEnhancer;","map":null,"metadata":{},"sourceType":"script"}