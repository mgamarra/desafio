{"ast":null,"code":"(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('error-stack-parser', ['stackframe'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('stackframe'));\n  } else {\n    root.ErrorStackParser = factory(root.StackFrame);\n  }\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n  function _map(array, fn, thisArg) {\n    if (typeof Array.prototype.map === 'function') {\n      return array.map(fn, thisArg);\n    } else {\n      var output = new Array(array.length);\n\n      for (var i = 0; i < array.length; i++) {\n        output[i] = fn.call(thisArg, array[i]);\n      }\n\n      return output;\n    }\n  }\n\n  function _filter(array, fn, thisArg) {\n    if (typeof Array.prototype.filter === 'function') {\n      return array.filter(fn, thisArg);\n    } else {\n      var output = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (fn.call(thisArg, array[i])) {\n          output.push(array[i]);\n        }\n      }\n\n      return output;\n    }\n  }\n\n  function _indexOf(array, target) {\n    if (typeof Array.prototype.indexOf === 'function') {\n      return array.indexOf(target);\n    } else {\n      for (var i = 0; i < array.length; i++) {\n        if (array[i] === target) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  }\n\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = _filter(error.stack.split('\\n'), function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n\n      return _map(filtered, function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n        }\n\n        var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = _filter(error.stack.split('\\n'), function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n\n      return _map(filtered, function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame(line);\n        } else {\n          var tokens = line.split('@');\n          var locationParts = this.extractLocation(tokens.pop());\n          var functionName = tokens.join('@') || undefined;\n          return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2], line);\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame(match[3] || undefined, undefined, match[2], match[1], undefined, lines[i]));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = _filter(error.stack.split('\\n'), function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n\n      return _map(filtered, function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^\\)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame(functionName, args, locationParts[0], locationParts[1], locationParts[2], line);\n      }, this);\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script"}